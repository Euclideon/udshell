#include "freetype.h"

#include "ep/cpp/component/file.h"
#include "ep/cpp/rect.h"

#define MAX_GLYPHS 256

namespace ep {

struct Pixel
{
  Pixel() : r(0), g(0), b(0), a(0) {}
  Pixel(uint8_t ri, uint8_t gi, uint8_t bi, uint8_t ai = 255)
    : r(ri), g(gi), b(bi), a(ai) {}

  uint8_t r, g, b, a;
};

FreeType::FreeType(const ComponentDesc *pType, Kernel *pKernel, SharedString uid, Variant::VarMap initParams)
  : Component(pType, pKernel, uid, initParams)
{
  FT_Error error = FT_Init_FreeType(&m_library);
  EPTHROW_IF(error != 0, Result::Failure, "Failed to initialize the FreeType Library. Error {0}", error);
}
FreeType::~FreeType()
{
  FT_Done_FreeType(m_library);
}

void *FreeType::createFont(Slice<const void> buffer, size_t faceIndex)
{
  // create the font
  FT_Face face;
  FT_Error error = FT_New_Memory_Face(m_library, (const FT_Byte*)buffer.ptr, (FT_Long)buffer.length, (FT_Long)faceIndex, &face);
  EPTHROW_IF(error != 0, Result::Failure, "Failed to create font. Error {0}", error);

  return (void*)face;
}

void FreeType::destroyFont(void *pFont)
{
  // 'done face'... really?
  FT_Done_Face((FT_Face)pFont);
}

size_t FreeType::getNumFaces(void *pFont) const
{
  return ((FT_Face)pFont)->num_faces;
}

Variant::VarMap::MapType FreeType::getMetadata(void *pFont) const
{
  FT_Face face = (FT_Face)pFont;

  Variant::VarMap::MapType metadata;
  metadata.insert("num_faces", face->num_faces);
  metadata.insert("face_index", face->face_index);
  metadata.insert("face_flags", face->face_flags);
  metadata.insert("style_flags", face->style_flags);
  metadata.insert("num_glyphs", face->num_glyphs);
  metadata.insert("family_name", face->family_name);
  metadata.insert("style_name", face->style_name);
  // TODO: expose these
//  metadata.insert("num_fixed_sizes", face->face_index);
//  metadata.insert("available_sizes", face->face_index);
//  metadata.insert("num_charmaps", face->face_index);
//  metadata.insert("charmaps", face->face_index);
//  metadata.insert("bbox", face->bbox);
  metadata.insert("units_per_EM", face->units_per_EM);
  metadata.insert("ascender", face->ascender);
  metadata.insert("descender", face->descender);
  metadata.insert("height", face->height);
  metadata.insert("max_advance_width", face->max_advance_width);
  metadata.insert("max_advance_height", face->max_advance_height);
  metadata.insert("underline_position", face->underline_position);
  metadata.insert("underline_thickness", face->underline_thickness);
  return metadata;
}

// A horizontal pixel span generated by the FreeType renderer.
struct Span
{
  Span() {}
  Span(int _x, int _y, int _width, int _coverage)
    : x(_x), y(_y), width(_width), coverage(_coverage) {}

  int x, y, width, coverage;
};

using Spans = Array<Span>;

// Each time the renderer calls us back we just push another span entry on our list.
static void rasterCallback(int y, int count, const FT_Span * const spans, void * const user)
{
  Spans *sptr = (Spans*)user;
  for (int i = 0; i < count; ++i)
  {
    sptr->pushBack();
    (*sptr)[sptr->size() - 1] = Span(spans[i].x, y, spans[i].len, spans[i].coverage);
  }
}

// Set up the raster parameters and render the outline.
static void renderSpans(const FT_Library &library, FT_Outline * const outline, Spans *spans)
{
  FT_Raster_Params params;
  memset(&params, 0, sizeof(params));
  params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
  params.gray_spans = rasterCallback;
  params.user = spans;

  FT_Outline_Render(library, outline, &params);
}

ArrayBufferRef FreeType::rasterizeText(void *pFont, String text, int fontSize, Float3 fontColor, Float3 outlineColor) const
{
  struct TGLyphs
  {
    FT_Vector pos;
    FT_Glyph glyph;
    FT_GlyphSlot slot;
    FT_Outline outline;
  };

  FT_Face face = (FT_Face)pFont;

  Array<TGLyphs, 256> glyphs;
  FT_Bool has_kerning;
  FT_UInt previous = 0;

  int xpos = 0, ypos = 0;

  int outlineWidth = 1;

  // Set the size to use. (0 mean same as height)
  if (FT_Set_Char_Size(face, 0, fontSize << 6, 90, 90) != 0)
    return nullptr;

  // Load the glyph we are looking for.
  const auto &tszChar = text.toStringz();

  Rect<int> rect{ 0, 0, 0, 0 };
  has_kerning = FT_HAS_KERNING(face);

  // Get the image size
  for (unsigned int i = 0; i < text.size(); i++)
  {
    //TODO: test if tszChar[i] == "\n" || == "\r\n"
    //if so increment ypos  and continue;
    FT_UInt gindex = FT_Get_Char_Index(face, tszChar[i]);

    // Use Kerning to make it nicer
    if (has_kerning && previous && gindex)
    {
      FT_Vector  delta;

      FT_Get_Kerning(face, previous, gindex,
        FT_KERNING_DEFAULT, &delta);

      xpos += delta.x >> 6;
    }

    if (FT_Load_Glyph(face, gindex, FT_LOAD_NO_BITMAP) == 0)
    {
      // Need an outline for this to work.
      if (face->glyph->format == FT_GLYPH_FORMAT_OUTLINE)
      {
        TGLyphs &currentGlyph = glyphs.pushBack();

        FT_Outline_New(m_library, face->glyph->outline.n_points, face->glyph->outline.n_contours, &currentGlyph.outline);
        FT_Error res = FT_Outline_Copy(&face->glyph->outline, &currentGlyph.outline);
        if (res != 0)
        {
          return nullptr;
        }

        if (FT_Get_Glyph(face->glyph, &currentGlyph.glyph) == 0)
        {
          currentGlyph.pos.x = xpos;
          currentGlyph.pos.y = ypos;

          FT_BBox  glyph_bbox;
          FT_Glyph_Get_CBox(currentGlyph.glyph, ft_glyph_bbox_pixels, &glyph_bbox);
          rect.expandToInclude(xpos + glyph_bbox.xMin - outlineWidth, ypos + glyph_bbox.yMin - outlineWidth);
          rect.expandToInclude(xpos + glyph_bbox.xMax + outlineWidth, ypos + glyph_bbox.yMax + outlineWidth);

          //Then increment xpos in function of the size of the glyph
          xpos += face->glyph->advance.x >> 6;
          previous = gindex;
        }
      }
    }
  }

  // Loop on all glyph in glyphs and fill the bitmap with the spans
  // Get some metrics of our image.
  const size_t imgWidth = rect.width, imgHeight = rect.height;

  // Allocate data for our image and clear it out to transparent.
  ArrayBufferRef spBuffer = Kernel::getInstance()->createComponent<ArrayBuffer>();

  // allocate image buffer
  spBuffer->allocate("u8[4]", sizeof(Pixel), Slice<const size_t>({imgWidth, imgHeight}));
  Slice<Pixel> textureMem = slice_cast<Slice<Pixel>>(spBuffer->map());
  epscope(fail) { spBuffer->unmap(); };

  // initialise the image buffer
  for (auto &p : textureMem)
    new(&p) Pixel();

  for (size_t i = 0; i < glyphs.length; i++)
  {
    // Span list for the glyph
    Spans spans;

    // Next we need the spans for the outline.
    Spans outlineSpans;

    //Render the basic glyph to a span list.
    renderSpans(m_library, &glyphs[i].outline, &spans);

    // Set up a stroker.
    FT_Stroker stroker;
    FT_Stroker_New(m_library, &stroker);
    FT_Stroker_Set(stroker, (outlineWidth * 64), FT_STROKER_LINECAP_ROUND, FT_STROKER_LINEJOIN_ROUND, 0);

    FT_Glyph_StrokeBorder(&glyphs[i].glyph, stroker, 0, 1);
    // Again, this needs to be an outline to work.
    if (glyphs[i].glyph->format == FT_GLYPH_FORMAT_OUTLINE)
    {
      // Render the outline spans to the span list
      FT_Outline *o = &reinterpret_cast<FT_OutlineGlyph>(glyphs[i].glyph)->outline;
      renderSpans(m_library, o, &outlineSpans);
    }

    // Clean up afterwards.
    FT_Stroker_Done(stroker);
    FT_Done_Glyph(glyphs[i].glyph);
    FT_Outline_Done(m_library, &glyphs[i].outline);

    // Now we need to put it all together.
    if (!spans.empty())
    {
      // Loop over the outline spans and just draw them into the image.
      for (ep::Iterator<Span> s = outlineSpans.begin(); s != outlineSpans.end(); ++s)
      {
        for (int w = 0; w < s->width; ++w)
        {
          size_t index = (imgHeight - 1 - (s->y + glyphs[i].pos.y - rect.y)) * imgWidth + s->x + glyphs[i].pos.x - rect.x + w;
          textureMem[index] = Pixel((uint8_t)(outlineColor.x * 255.f + 0.5f), (uint8_t)(outlineColor.y * 255.f + 0.5f), (uint8_t)(outlineColor.z * 255.f + 0.5f), (uint8_t)s->coverage);
        }
      }

      // Then loop over the regular glyph spans and blend them into the image.
      for (ep::Iterator<Span> s = spans.begin(); s != spans.end(); ++s)
        for (int w = 0; w < s->width; ++w)
        {
          Pixel &dst = textureMem[(imgHeight - 1 - (s->y + glyphs[i].pos.y - rect.y)) * imgWidth + s->x + glyphs[i].pos.x - rect.x + w];
          Pixel src((uint8_t)(fontColor.x * 255.f + 0.5f), (uint8_t)(fontColor.y * 255.f + 0.5f), (uint8_t)(fontColor.z * 255.f + 0.5f), (uint8_t)s->coverage);
          dst.r = (uint8_t)(dst.r + ((src.r - dst.r) * src.a) / 255.0f);
          dst.g = (uint8_t)(dst.g + ((src.g - dst.g) * src.a) / 255.0f);
          dst.b = (uint8_t)(dst.b + ((src.b - dst.b) * src.a) / 255.0f);
          dst.a = (255 < dst.a + s->coverage) ? 255 : (uint8_t)(dst.a + s->coverage);
        }
    }
  }

  spBuffer->unmap();

  return spBuffer;
}

} // namespace ep
